{"ast":null,"code":"/* Copyright 2015-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar os = require('os');\n\nvar assert = require('assert');\n\nvar Int64 = require('node-int64'); // BSER uses the local endianness to reduce byte swapping overheads\n// (the protocol is expressly local IPC only).  We need to tell node\n// to use the native endianness when reading various native values.\n\n\nvar isBigEndian = os.endianness() == 'BE'; // Find the next power-of-2 >= size\n\nfunction nextPow2(size) {\n  return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));\n} // Expandable buffer that we can provide a size hint for\n\n\nfunction Accumulator(initsize) {\n  this.buf = new Buffer(nextPow2(initsize || 8192));\n  this.readOffset = 0;\n  this.writeOffset = 0;\n} // For testing\n\n\nexports.Accumulator = Accumulator; // How much we can write into this buffer without allocating\n\nAccumulator.prototype.writeAvail = function () {\n  return this.buf.length - this.writeOffset;\n}; // How much we can read\n\n\nAccumulator.prototype.readAvail = function () {\n  return this.writeOffset - this.readOffset;\n}; // Ensure that we have enough space for size bytes\n\n\nAccumulator.prototype.reserve = function (size) {\n  if (size < this.writeAvail()) {\n    return;\n  } // If we can make room by shunting down, do so\n\n\n  if (this.readOffset > 0) {\n    this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);\n    this.writeOffset -= this.readOffset;\n    this.readOffset = 0;\n  } // If we made enough room, no need to allocate more\n\n\n  if (size < this.writeAvail()) {\n    return;\n  } // Allocate a replacement and copy it in\n\n\n  var buf = new Buffer(nextPow2(this.buf.length + size - this.writeAvail()));\n  this.buf.copy(buf);\n  this.buf = buf;\n}; // Append buffer or string.  Will resize as needed\n\n\nAccumulator.prototype.append = function (buf) {\n  if (Buffer.isBuffer(buf)) {\n    this.reserve(buf.length);\n    buf.copy(this.buf, this.writeOffset, 0, buf.length);\n    this.writeOffset += buf.length;\n  } else {\n    var size = Buffer.byteLength(buf);\n    this.reserve(size);\n    this.buf.write(buf, this.writeOffset);\n    this.writeOffset += size;\n  }\n};\n\nAccumulator.prototype.assertReadableSize = function (size) {\n  if (this.readAvail() < size) {\n    throw new Error(\"wanted to read \" + size + \" bytes but only have \" + this.readAvail());\n  }\n};\n\nAccumulator.prototype.peekString = function (size) {\n  this.assertReadableSize(size);\n  return this.buf.toString('utf-8', this.readOffset, this.readOffset + size);\n};\n\nAccumulator.prototype.readString = function (size) {\n  var str = this.peekString(size);\n  this.readOffset += size;\n  return str;\n};\n\nAccumulator.prototype.peekInt = function (size) {\n  this.assertReadableSize(size);\n\n  switch (size) {\n    case 1:\n      return this.buf.readInt8(this.readOffset, size);\n\n    case 2:\n      return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);\n\n    case 4:\n      return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);\n\n    case 8:\n      var big = this.buf.slice(this.readOffset, this.readOffset + 8);\n\n      if (isBigEndian) {\n        // On a big endian system we can simply pass the buffer directly\n        return new Int64(big);\n      } // Otherwise we need to byteswap\n\n\n      return new Int64(byteswap64(big));\n\n    default:\n      throw new Error(\"invalid integer size \" + size);\n  }\n};\n\nAccumulator.prototype.readInt = function (bytes) {\n  var ival = this.peekInt(bytes);\n  this.readOffset += bytes;\n  return ival;\n};\n\nAccumulator.prototype.peekDouble = function () {\n  this.assertReadableSize(8);\n  return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);\n};\n\nAccumulator.prototype.readDouble = function () {\n  var dval = this.peekDouble();\n  this.readOffset += 8;\n  return dval;\n};\n\nAccumulator.prototype.readAdvance = function (size) {\n  if (size > 0) {\n    this.assertReadableSize(size);\n  } else if (size < 0 && this.readOffset + size < 0) {\n    throw new Error(\"advance with negative offset \" + size + \" would seek off the start of the buffer\");\n  }\n\n  this.readOffset += size;\n};\n\nAccumulator.prototype.writeByte = function (value) {\n  this.reserve(1);\n  this.buf.writeInt8(value, this.writeOffset);\n  ++this.writeOffset;\n};\n\nAccumulator.prototype.writeInt = function (value, size) {\n  this.reserve(size);\n\n  switch (size) {\n    case 1:\n      this.buf.writeInt8(value, this.writeOffset);\n      break;\n\n    case 2:\n      if (isBigEndian) {\n        this.buf.writeInt16BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt16LE(value, this.writeOffset);\n      }\n\n      break;\n\n    case 4:\n      if (isBigEndian) {\n        this.buf.writeInt32BE(value, this.writeOffset);\n      } else {\n        this.buf.writeInt32LE(value, this.writeOffset);\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unsupported integer size \" + size);\n  }\n\n  this.writeOffset += size;\n};\n\nAccumulator.prototype.writeDouble = function (value) {\n  this.reserve(8);\n\n  if (isBigEndian) {\n    this.buf.writeDoubleBE(value, this.writeOffset);\n  } else {\n    this.buf.writeDoubleLE(value, this.writeOffset);\n  }\n\n  this.writeOffset += 8;\n};\n\nvar BSER_ARRAY = 0x00;\nvar BSER_OBJECT = 0x01;\nvar BSER_STRING = 0x02;\nvar BSER_INT8 = 0x03;\nvar BSER_INT16 = 0x04;\nvar BSER_INT32 = 0x05;\nvar BSER_INT64 = 0x06;\nvar BSER_REAL = 0x07;\nvar BSER_TRUE = 0x08;\nvar BSER_FALSE = 0x09;\nvar BSER_NULL = 0x0a;\nvar BSER_TEMPLATE = 0x0b;\nvar BSER_SKIP = 0x0c;\nvar ST_NEED_PDU = 0; // Need to read and decode PDU length\n\nvar ST_FILL_PDU = 1; // Know the length, need to read whole content\n\nvar MAX_INT8 = 127;\nvar MAX_INT16 = 32768;\nvar MAX_INT32 = 2147483648;\n\nfunction BunserBuf() {\n  EE.call(this);\n  this.buf = new Accumulator();\n  this.state = ST_NEED_PDU;\n}\n\nutil.inherits(BunserBuf, EE);\nexports.BunserBuf = BunserBuf;\n\nBunserBuf.prototype.append = function (buf, synchronous) {\n  if (synchronous) {\n    this.buf.append(buf);\n    return this.process(synchronous);\n  }\n\n  try {\n    this.buf.append(buf);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  } // Arrange to decode later.  This allows the consuming\n  // application to make progress with other work in the\n  // case that we have a lot of subscription updates coming\n  // in from a large tree.\n\n\n  this.processLater();\n};\n\nBunserBuf.prototype.processLater = function () {\n  var self = this;\n  process.nextTick(function () {\n    try {\n      self.process(false);\n    } catch (err) {\n      self.emit('error', err);\n    }\n  });\n}; // Do something with the buffer to advance our state.\n// If we're running synchronously we'll return either\n// the value we've decoded or undefined if we don't\n// yet have enought data.\n// If we're running asynchronously, we'll emit the value\n// when it becomes ready and schedule another invocation\n// of process on the next tick if we still have data we\n// can process.\n\n\nBunserBuf.prototype.process = function (synchronous) {\n  if (this.state == ST_NEED_PDU) {\n    if (this.buf.readAvail() < 2) {\n      return;\n    } // Validate BSER header\n\n\n    this.expectCode(0);\n    this.expectCode(1);\n    this.pduLen = this.decodeInt(true\n    /* relaxed */\n    );\n\n    if (this.pduLen === false) {\n      // Need more data, walk backwards\n      this.buf.readAdvance(-2);\n      return;\n    } // Ensure that we have a big enough buffer to read the rest of the PDU\n\n\n    this.buf.reserve(this.pduLen);\n    this.state = ST_FILL_PDU;\n  }\n\n  if (this.state == ST_FILL_PDU) {\n    if (this.buf.readAvail() < this.pduLen) {\n      // Need more data\n      return;\n    } // We have enough to decode it\n\n\n    var val = this.decodeAny();\n\n    if (synchronous) {\n      return val;\n    }\n\n    this.emit('value', val);\n    this.state = ST_NEED_PDU;\n  }\n\n  if (!synchronous && this.buf.readAvail() > 0) {\n    this.processLater();\n  }\n};\n\nBunserBuf.prototype.raise = function (reason) {\n  throw new Error(reason + \", in Buffer of length \" + this.buf.buf.length + \" (\" + this.buf.readAvail() + \" readable) at offset \" + this.buf.readOffset + \" buffer: \" + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));\n};\n\nBunserBuf.prototype.expectCode = function (expected) {\n  var code = this.buf.readInt(1);\n\n  if (code != expected) {\n    this.raise(\"expected bser opcode \" + expected + \" but got \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeAny = function () {\n  var code = this.buf.peekInt(1);\n\n  switch (code) {\n    case BSER_INT8:\n    case BSER_INT16:\n    case BSER_INT32:\n    case BSER_INT64:\n      return this.decodeInt();\n\n    case BSER_REAL:\n      this.buf.readAdvance(1);\n      return this.buf.readDouble();\n\n    case BSER_TRUE:\n      this.buf.readAdvance(1);\n      return true;\n\n    case BSER_FALSE:\n      this.buf.readAdvance(1);\n      return false;\n\n    case BSER_NULL:\n      this.buf.readAdvance(1);\n      return null;\n\n    case BSER_STRING:\n      return this.decodeString();\n\n    case BSER_ARRAY:\n      return this.decodeArray();\n\n    case BSER_OBJECT:\n      return this.decodeObject();\n\n    case BSER_TEMPLATE:\n      return this.decodeTemplate();\n\n    default:\n      this.raise(\"unhandled bser opcode \" + code);\n  }\n};\n\nBunserBuf.prototype.decodeArray = function () {\n  this.expectCode(BSER_ARRAY);\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    arr.push(this.decodeAny());\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeObject = function () {\n  this.expectCode(BSER_OBJECT);\n  var nitems = this.decodeInt();\n  var res = {};\n\n  for (var i = 0; i < nitems; ++i) {\n    var key = this.decodeString();\n    var val = this.decodeAny();\n    res[key] = val;\n  }\n\n  return res;\n};\n\nBunserBuf.prototype.decodeTemplate = function () {\n  this.expectCode(BSER_TEMPLATE);\n  var keys = this.decodeArray();\n  var nitems = this.decodeInt();\n  var arr = [];\n\n  for (var i = 0; i < nitems; ++i) {\n    var obj = {};\n\n    for (var keyidx = 0; keyidx < keys.length; ++keyidx) {\n      if (this.buf.peekInt(1) == BSER_SKIP) {\n        this.buf.readAdvance(1);\n        continue;\n      }\n\n      var val = this.decodeAny();\n      obj[keys[keyidx]] = val;\n    }\n\n    arr.push(obj);\n  }\n\n  return arr;\n};\n\nBunserBuf.prototype.decodeString = function () {\n  this.expectCode(BSER_STRING);\n  var len = this.decodeInt();\n  return this.buf.readString(len);\n}; // This is unusual compared to the other decode functions in that\n// we may not have enough data available to satisfy the read, and\n// we don't want to throw.  This is only true when we're reading\n// the PDU length from the PDU header; we'll set relaxSizeAsserts\n// in that case.\n\n\nBunserBuf.prototype.decodeInt = function (relaxSizeAsserts) {\n  if (relaxSizeAsserts && !this.buf.readAvail(1)) {\n    return false;\n  } else {\n    this.buf.assertReadableSize(1);\n  }\n\n  var code = this.buf.peekInt(1);\n  var size = 0;\n\n  switch (code) {\n    case BSER_INT8:\n      size = 1;\n      break;\n\n    case BSER_INT16:\n      size = 2;\n      break;\n\n    case BSER_INT32:\n      size = 4;\n      break;\n\n    case BSER_INT64:\n      size = 8;\n      break;\n\n    default:\n      this.raise(\"invalid bser int encoding \" + code);\n  }\n\n  if (relaxSizeAsserts && !this.buf.readAvail(1 + size)) {\n    return false;\n  }\n\n  this.buf.readAdvance(1);\n  return this.buf.readInt(size);\n}; // synchronously BSER decode a string and return the value\n\n\nfunction loadFromBuffer(input) {\n  var buf = new BunserBuf();\n  var result = buf.append(input, true);\n\n  if (buf.buf.readAvail()) {\n    throw Error('excess data found after input buffer, use BunserBuf instead');\n  }\n\n  if (typeof result === 'undefined') {\n    throw Error('no bser found in string and no error raised!?');\n  }\n\n  return result;\n}\n\nexports.loadFromBuffer = loadFromBuffer; // Byteswap an arbitrary buffer, flipping from one endian\n// to the other, returning a new buffer with the resultant data\n\nfunction byteswap64(buf) {\n  var swap = new Buffer(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    swap[i] = buf[buf.length - 1 - i];\n  }\n\n  return swap;\n}\n\nfunction dump_int64(buf, val) {\n  // Get the raw bytes.  The Int64 buffer is big endian\n  var be = val.toBuffer();\n\n  if (isBigEndian) {\n    // We're a big endian system, so the buffer is exactly how we\n    // want it to be\n    buf.writeByte(BSER_INT64);\n    buf.append(be);\n    return;\n  } // We need to byte swap to get the correct representation\n\n\n  var le = byteswap64(be);\n  buf.writeByte(BSER_INT64);\n  buf.append(le);\n}\n\nfunction dump_int(buf, val) {\n  var abs = Math.abs(val);\n\n  if (abs <= MAX_INT8) {\n    buf.writeByte(BSER_INT8);\n    buf.writeInt(val, 1);\n  } else if (abs <= MAX_INT16) {\n    buf.writeByte(BSER_INT16);\n    buf.writeInt(val, 2);\n  } else if (abs <= MAX_INT32) {\n    buf.writeByte(BSER_INT32);\n    buf.writeInt(val, 4);\n  } else {\n    dump_int64(buf, new Int64(val));\n  }\n}\n\nfunction dump_any(buf, val) {\n  switch (typeof val) {\n    case 'number':\n      buf.writeByte(BSER_REAL);\n      buf.writeDouble(val);\n      return;\n\n    case 'string':\n      buf.writeByte(BSER_STRING);\n      dump_int(buf, Buffer.byteLength(val));\n      buf.append(val);\n      return;\n\n    case 'boolean':\n      buf.writeByte(val ? BSER_TRUE : BSER_FALSE);\n      return;\n\n    case 'object':\n      if (val === null) {\n        buf.writeByte(BSER_NULL);\n        return;\n      }\n\n      if (val instanceof Int64) {\n        dump_int64(buf, val);\n        return;\n      }\n\n      if (Array.isArray(val)) {\n        buf.writeByte(BSER_ARRAY);\n        dump_int(buf, val.length);\n\n        for (var i = 0; i < val.length; ++i) {\n          dump_any(buf, val[i]);\n        }\n\n        return;\n      }\n\n      buf.writeByte(BSER_OBJECT);\n      var keys = Object.keys(val); // First pass to compute number of defined keys\n\n      var num_keys = keys.length;\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          num_keys--;\n        }\n      }\n\n      dump_int(buf, num_keys);\n\n      for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var v = val[key];\n\n        if (typeof v == 'undefined') {\n          // Don't include it\n          continue;\n        }\n\n        dump_any(buf, key);\n\n        try {\n          dump_any(buf, v);\n        } catch (e) {\n          throw new Error(e.message + ' (while serializing object property with name `' + key + \"')\");\n        }\n      }\n\n      return;\n\n    default:\n      throw new Error('cannot serialize type ' + typeof val + ' to BSER');\n  }\n} // BSER encode value and return a buffer of the contents\n\n\nfunction dumpToBuffer(val) {\n  var buf = new Accumulator(); // Build out the header\n\n  buf.writeByte(0);\n  buf.writeByte(1); // Reserve room for an int32 to hold our PDU length\n\n  buf.writeByte(BSER_INT32);\n  buf.writeInt(0, 4); // We'll come back and fill this in at the end\n\n  dump_any(buf, val); // Compute PDU length\n\n  var off = buf.writeOffset;\n  var len = off - 7\n  /* the header length */\n  ;\n  buf.writeOffset = 3; // The length value to fill in\n\n  buf.writeInt(len, 4); // write the length in the space we reserved\n\n  buf.writeOffset = off;\n  return buf.buf.slice(0, off);\n}\n\nexports.dumpToBuffer = dumpToBuffer;","map":null,"metadata":{},"sourceType":"script"}