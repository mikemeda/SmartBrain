{"ast":null,"code":"/* Copyright 2014-present Facebook, Inc.\n * Licensed under the Apache License, Version 2.0 */\n'use strict';\n\nvar net = require('net');\n\nvar EE = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar childProcess = require('child_process');\n\nvar bser = require('bser'); // We'll emit the responses to these when they get sent down to us\n\n\nvar unilateralTags = ['subscription', 'log'];\n/**\n * @param options An object with the following optional keys:\n *   * 'watchmanBinaryPath' (string) Absolute path to the watchman binary.\n *     If not provided, the Client locates the binary using the PATH specified\n *     by the node child_process's default env.\n */\n\nfunction Client(options) {\n  var self = this;\n  EE.call(this);\n  this.watchmanBinaryPath = 'watchman';\n\n  if (options && options.watchmanBinaryPath) {\n    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();\n  }\n\n  ;\n  this.commands = [];\n}\n\nutil.inherits(Client, EE);\nmodule.exports.Client = Client; // Try to send the next queued command, if any\n\nClient.prototype.sendNextCommand = function () {\n  if (this.currentCommand) {\n    // There's a command pending response, don't send this new one yet\n    return;\n  }\n\n  this.currentCommand = this.commands.shift();\n\n  if (!this.currentCommand) {\n    // No further commands are queued\n    return;\n  }\n\n  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));\n};\n\nClient.prototype.cancelCommands = function (why) {\n  var error = new Error(why); // Steal all pending commands before we start cancellation, in\n  // case something decides to schedule more commands\n\n  var cmds = this.commands;\n  this.commands = [];\n\n  if (this.currentCommand) {\n    cmds.unshift(this.currentCommand);\n    this.currentCommand = null;\n  } // Synthesize an error condition for any commands that were queued\n\n\n  cmds.forEach(function (cmd) {\n    cmd.cb(error);\n  });\n};\n\nClient.prototype.connect = function () {\n  var self = this;\n\n  function makeSock(sockname) {\n    // bunser will decode the watchman BSER protocol for us\n    self.bunser = new bser.BunserBuf(); // For each decoded line:\n\n    self.bunser.on('value', function (obj) {\n      // Figure out if this is a unliteral response or if it is the\n      // response portion of a request-response sequence.  At the time\n      // of writing, there are only two possible unilateral responses.\n      var unilateral = false;\n\n      for (var i = 0; i < unilateralTags.length; i++) {\n        var tag = unilateralTags[i];\n\n        if (tag in obj) {\n          unilateral = tag;\n        }\n      }\n\n      if (unilateral) {\n        self.emit(unilateral, obj);\n      } else if (self.currentCommand) {\n        var cmd = self.currentCommand;\n        self.currentCommand = null;\n\n        if ('error' in obj) {\n          var error = new Error(obj.error);\n          error.watchmanResponse = obj;\n          cmd.cb(error);\n        } else {\n          cmd.cb(null, obj);\n        }\n      } // See if we can dispatch the next queued command, if any\n\n\n      self.sendNextCommand();\n    });\n    self.bunser.on('error', function (err) {\n      self.emit('error', err);\n    });\n    self.socket = net.createConnection(sockname);\n    self.socket.on('connect', function () {\n      self.connecting = false;\n      self.emit('connect');\n      self.sendNextCommand();\n    });\n    self.socket.on('error', function (err) {\n      self.connecting = false;\n      self.emit('error', err);\n    });\n    self.socket.on('data', function (buf) {\n      if (self.bunser) {\n        self.bunser.append(buf);\n      }\n    });\n    self.socket.on('end', function () {\n      self.socket = null;\n      self.bunser = null;\n      self.cancelCommands('The watchman connection was closed');\n      self.emit('end');\n    });\n  } // triggers will export the sock path to the environment.\n  // If we're invoked in such a way, we can simply pick up the\n  // definition from the environment and avoid having to fork off\n  // a process to figure it out\n\n\n  if (process.env.WATCHMAN_SOCK) {\n    makeSock(process.env.WATCHMAN_SOCK);\n    return;\n  } // We need to ask the client binary where to find it.\n  // This will cause the service to start for us if it isn't\n  // already running.\n\n\n  var args = ['--no-pretty', 'get-sockname']; // We use the more elaborate spawn rather than exec because there\n  // are some error cases on Windows where process spawning can hang.\n  // It is desirable to pipe stderr directly to stderr live so that\n  // we can discover the problem.\n\n  var proc = null;\n  var spawnFailed = false;\n\n  function spawnError(error) {\n    if (spawnFailed) {\n      // For ENOENT, proc 'close' will also trigger with a negative code,\n      // let's suppress that second error.\n      return;\n    }\n\n    spawnFailed = true;\n\n    if (error.errno === 'EACCES') {\n      error.message = 'The Watchman CLI is installed but cannot ' + 'be spawned because of a permission problem';\n    } else if (error.errno === 'ENOENT') {\n      error.message = 'Watchman was not found in PATH.  See ' + 'https://facebook.github.io/watchman/docs/install.html ' + 'for installation instructions';\n    }\n\n    console.error('Watchman: ', error.message);\n    self.emit('error', error);\n  }\n\n  try {\n    proc = childProcess.spawn(this.watchmanBinaryPath, args, {\n      stdio: ['ignore', 'pipe', 'pipe']\n    });\n  } catch (error) {\n    spawnError(error);\n    return;\n  }\n\n  var stdout = [];\n  var stderr = [];\n  proc.stdout.on('data', function (data) {\n    stdout.push(data);\n  });\n  proc.stderr.on('data', function (data) {\n    data = data.toString('utf8');\n    stderr.push(data);\n    console.error(data);\n  });\n  proc.on('error', function (error) {\n    spawnError(error);\n  });\n  proc.on('close', function (code, signal) {\n    if (code !== 0) {\n      spawnError(new Error(self.watchmanBinaryPath + ' ' + args.join(' ') + ' returned with exit code=' + code + ', signal=' + signal + ', stderr= ' + stderr.join('')));\n      return;\n    }\n\n    try {\n      var obj = JSON.parse(stdout.join(''));\n\n      if ('error' in obj) {\n        var error = new Error(obj.error);\n        error.watchmanResponse = obj;\n        self.emit('error', error);\n        return;\n      }\n\n      makeSock(obj.sockname);\n    } catch (e) {\n      self.emit('error', e);\n    }\n  });\n};\n\nClient.prototype.command = function (args, done) {\n  done = done || function () {}; // Queue up the command\n\n\n  this.commands.push({\n    cmd: args,\n    cb: done\n  }); // Establish a connection if we don't already have one\n\n  if (!this.socket) {\n    if (!this.connecting) {\n      this.connecting = true;\n      this.connect();\n      return;\n    }\n\n    return;\n  } // If we're already connected and idle, try sending the command immediately\n\n\n  this.sendNextCommand();\n};\n\nvar cap_versions = {\n  \"cmd-watch-del-all\": \"3.1.1\",\n  \"cmd-watch-project\": \"3.1\",\n  \"relative_root\": \"3.3\",\n  \"term-dirname\": \"3.1\",\n  \"term-idirname\": \"3.1\",\n  \"wildmatch\": \"3.7\" // Compares a vs b, returns < 0 if a < b, > 0 if b > b, 0 if a == b\n\n};\n\nfunction vers_compare(a, b) {\n  a = a.split('.');\n  b = b.split('.');\n\n  for (var i = 0; i < 3; i++) {\n    var d = parseInt(a[i] || '0') - parseInt(b[i] || '0');\n\n    if (d != 0) {\n      return d;\n    }\n  }\n\n  return 0; // Equal\n}\n\nfunction have_cap(vers, name) {\n  if (name in cap_versions) {\n    return vers_compare(vers, cap_versions[name]) >= 0;\n  }\n\n  return false;\n} // This is a helper that we expose for testing purposes\n\n\nClient.prototype._synthesizeCapabilityCheck = function (resp, optional, required) {\n  resp.capabilities = {};\n  var version = resp.version;\n  optional.forEach(function (name) {\n    resp.capabilities[name] = have_cap(version, name);\n  });\n  required.forEach(function (name) {\n    var have = have_cap(version, name);\n    resp.capabilities[name] = have;\n\n    if (!have) {\n      resp.error = 'client required capability `' + name + '` is not supported by this server';\n    }\n  });\n  return resp;\n};\n\nClient.prototype.capabilityCheck = function (caps, done) {\n  var optional = caps.optional || [];\n  var required = caps.required || [];\n  var self = this;\n  this.command(['version', {\n    optional: optional,\n    required: required\n  }], function (error, resp) {\n    if (error) {\n      done(error);\n      return;\n    }\n\n    if (!('capabilities' in resp)) {\n      // Server doesn't support capabilities, so we need to\n      // synthesize the results based on the version\n      resp = self._synthesizeCapabilityCheck(resp, optional, required);\n\n      if (resp.error) {\n        error = new Error(resp.error);\n        error.watchmanResponse = resp;\n        done(error);\n        return;\n      }\n    }\n\n    done(null, resp);\n  });\n}; // Close the connection to the service\n\n\nClient.prototype.end = function () {\n  this.cancelCommands('The client was ended');\n\n  if (this.socket) {\n    this.socket.end();\n    this.socket = null;\n  }\n\n  this.bunser = null;\n};","map":null,"metadata":{},"sourceType":"script"}